<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="UTF-8">
<title>게시글 상세보기</title>
<style>
.view-container {
	max-width: 800px;
	margin: 0 auto;
	padding: 20px;
	background-color: #fff;
	box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
	border-radius: 5px;
	font-family: Arial, sans-serif;
}

.view-header {
	margin-bottom: 20px;
	border-bottom: 1px solid #eee;
}

.view-header h2 {
	margin: 0;
}

.view-meta {
	font-size: 14px;
	color: #666;
	margin-top: 5px;
}

.view-content {
	margin: 20px 0;
	white-space: pre-wrap;
}

.attached-files {
	background-color: #f9f9f9;
	padding: 10px;
	border-radius: 4px;
	margin-top: 20px;
}

.attached-files li {
	margin: 5px 0;
}

.btn-group {
	margin-top: 30px;
	display: flex;
	gap: 10px;
}

.btn {
	padding: 8px 16px;
	border: none;
	border-radius: 4px;
	text-decoration: none;
	color: white;
	font-size: 14px;
	cursor: pointer;
}

.btn-back {
	background-color: #6c757d;
}

.btn-edit {
	background-color: #007bff;
}

.btn-delete {
	background-color: #dc3545;
}
/* 지도 스타일 */
#post-map {
	width: 100%;
	height: 350px;
	margin: 20px 0;
	border-radius: 8px;
	box-shadow: 0 0 8px rgba(0, 0, 0, 0.06);
}
</style>
<!-- jQuery 라이브러리 추가 -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<!-- 카카오맵 API 스크립트 -->
<script type="text/javascript"
	src="//dapi.kakao.com/v2/maps/sdk.js?appkey=6cf3d7111812f0d90ad76a99a16d0f39&autoload=false&libraries=services"></script>
</head>
<body>
	<div class="view-container">
		<div class="view-header">
			<h2 th:utext="${post.title}">게시글 제목</h2>
			<div class="view-meta">
				작성자: <span th:utext="${post.username}"></span> | 지역: <span
					th:utext="${post.region}"></span> | 조회수: <span
					th:utext="${post.views}"></span>
			</div>
		</div>

		<div class="view-content" th:utext="${post.content}">게시글 내용</div>

		<!-- 지도 표시 영역 추가 -->
		<div id="post-map"></div>


		<div class="attached-files"
			th:if="${post.files != null and !post.files.isEmpty()}">
			<strong>첨부파일:</strong>
			<ul>
				<li th:each="file : ${post.files}"><a
					th:href="@{|/files/${file.uuid}_${file.originalName}|}"
					th:utext="${file.originalName}" download></a></li>
			</ul>
		</div>

		<div class="btn-group">
			<a th:href="@{/post/list}" class="btn btn-back">목록으로</a>


			<th:block th:if="${post.user_id} == ${sessionUserId}">
				<a th:href="@{/post/edit/{id}(id=${post.post_id})}"
					class="btn btn-edit">수정</a>
				<form th:action="@{/post/delete/{id}(id=${post.post_id})}"
					method="post" style="display: inline;">
					<button type="submit" class="btn btn-delete"
						onclick="return confirm('정말 삭제하시겠습니까?');">삭제</button>
				</form>
			</th:block>
		</div>

		<!-- 이미지 출력 -->
		<div class="image-gallery">
			<h3>이미지</h3>
			<div>
				<div th:each="file : ${fileList}"><img
					th:src="@{'/file/preview/' + ${file.fileId}}"
					style="max-width: 300px;" /></div>
			</div>
		</div>
		
		<div class="comment-section">
			<h3>댓글</h3>
			<textarea id="commentContent" placeholder="댓글을 입력하세요"
				style="width: 100%; height: 80px;"></textarea>
			<br>
			<button onclick="submitComment()">댓글 등록</button>
			<div id="commentList" style="margin-top: 20px;"></div>
		</div>
	</div>

	<!-- 카카오맵과 댓글 기능을 위한 스크립트 -->
	<script th:inline="javascript">
    // 서버에서 받은 데이터를 전역 변수로 설정
    const postId = [[${post.post_id}]];
    const currentUserId = [[${user_id}]];
    const latitude = [[${post.lat}]];
    const longitude = [[${post.lng}]];
    const csrfToken = [[${_csrf != null ? _csrf.token : ''}]];
    const csrfHeader = [[${_csrf != null ? _csrf.headerName : 'X-CSRF-TOKEN'}]];
    const isLoggedIn = [[${session.userId != null}]];
    
    // AJAX 설정에 CSRF 토큰 추가
    $.ajaxSetup({
      beforeSend: function(xhr) {
        if (csrfToken) {
          xhr.setRequestHeader(csrfHeader, csrfToken);
        }
      }
    });
    
    // 댓글 관련 함수
   function submitComment() {
    const content = $('#commentContent').val();
    if (!content.trim()) {
      alert('댓글을 입력하세요.');
      return;
    }

    $.ajax({
      url: '/api/comments',
      method: 'POST',
      contentType: 'application/json',
      xhrFields: { withCredentials: true },
      data: JSON.stringify({ content: content, post_id: postId }),
      success: function() {
        $('#commentContent').val('');
        loadComments();
      },
      error: function(xhr) {
        if (xhr.status === 401) {
          alert('로그인이 필요합니다.');
          window.location.href = '/login';
        } else {
          alert('댓글 등록 실패');
        }
      }
    });
  }

  function loadComments() {
    $.ajax({
      url: '/api/comments/' + postId,
      method: 'GET',
      success: function(comments) {
        let html = '';
        const commentMap = {};
        comments.forEach(comment => {
          commentMap[comment.comment_id] = comment;
          comment.replies = [];
        });

        const roots = [];
        comments.forEach(comment => {
          if (comment.parent_id) {
            const parent = commentMap[comment.parent_id];
            if (parent) parent.replies.push(comment);
          } else {
            roots.push(comment);
          }
        });

        function renderComments(commentList, depth) {
          commentList.forEach(comment => {
            const marginLeft = depth * 20;
            html += `<div style="margin-left:${marginLeft}px; margin-bottom:10px;">`;
            html += `<strong>${comment.nickname || '익명'}</strong><br>`;
            html += `${comment.content}<br>`;
            html += `<small>${comment.created_at?.replace('T', ' ').substring(0,19) || ''}</small><br>`;
            html += `<button onclick="toggleLike(${comment.comment_id})">좋아요 (${comment.like_count || 0})</button>`;
            console.log("currentUserId =", currentUserId);

            if (currentUserId && comment.user_id === currentUserId) {
              html += `<button onclick="editComment(${comment.comment_id}, '${comment.content}')">수정</button>`;
              html += `<button onclick="deleteComment(${comment.comment_id})">삭제</button>`;
            }
            if (currentUserId) {
              html += `<button onclick="replyComment(${comment.comment_id})">답글</button>`;
            }
            html += `</div>`;
            if (comment.replies.length > 0) {
              renderComments(comment.replies, depth + 1);
            }
          });
        }

        renderComments(roots, 0);
        $('#commentList').html(html);
      },
      error: function() {
        alert('댓글 불러오기 실패');
      }
    });
  }

  function toggleLike(commentId) {
    $.ajax({
      url: '/api/comments/' + commentId + '/like',
      method: 'POST',
      xhrFields: { withCredentials: true },
      success: loadComments,
      error: function(xhr) {
        if (xhr.status === 401) {
          alert('로그인이 필요합니다.');
          window.location.href = '/login';
        } else {
          alert('좋아요 실패');
        }
      }
    });
  }

  function deleteComment(commentId) {
    if (!confirm('정말 삭제하시겠습니까?')) return;
    $.ajax({
      url: '/api/comments/' + commentId,
      method: 'DELETE',
      xhrFields: { withCredentials: true },
      success: loadComments,
      error: function() {
        alert('댓글 삭제 실패');
      }
    });
  }

  function editComment(commentId, oldContent) {
    const newContent = prompt('댓글 수정:', oldContent);
    if (!newContent || newContent.trim() === '') return;

    $.ajax({
      url: '/api/comments/' + commentId,
      method: 'PUT',
      contentType: 'application/json',
      xhrFields: { withCredentials: true },
      data: JSON.stringify({ content: newContent }),
      success: loadComments,
      error: function() {
        alert('댓글 수정 실패');
      }
    });
  }

  function replyComment(parentId) {
    const reply = prompt('답글 작성:');
    if (!reply || reply.trim() === '') return;

    $.ajax({
      url: '/api/comments',
      method: 'POST',
      contentType: 'application/json',
      xhrFields: { withCredentials: true },
      data: JSON.stringify({ content: reply, post_id: postId, parent_id: parentId }),
      success: loadComments,
      error: function() {
        alert('답글 작성 실패');
      }
    });
    }

    // 카카오맵 관련 함수
    function initKakaoMap() {
      kakao.maps.load(function() {
        if (latitude && longitude) {
          var mapContainer = document.getElementById('post-map');
          var mapOption = {
            center: new kakao.maps.LatLng(latitude, longitude),
            level: 3
          };
          var map = new kakao.maps.Map(mapContainer, mapOption);
          var marker = new kakao.maps.Marker({
            map: map,
            position: new kakao.maps.LatLng(latitude, longitude)
          });

          var places = new kakao.maps.services.Places();
          var geocoder = new kakao.maps.services.Geocoder();
          
          // 1. 대형 랜드마크 검색을 위한 설정
          places.keywordSearch('관광명소', function(data, status) {
            var placeName = null;
            
            // 관광명소 검색 성공 시
            if (status === kakao.maps.services.Status.OK && data.length > 0) {
              var nearestPlace = findNearestPlace(data, latitude, longitude);
              
              // 1km 이내의 관광명소만 표시
              if (calculateDistance(latitude, longitude, nearestPlace.y, nearestPlace.x) < 1000) {
                placeName = nearestPlace.place_name;
                
                // 카테고리 확인 (테마파크/리조트 등)
                if (nearestPlace.category_name.includes('관광명소') || 
                    nearestPlace.category_name.includes('테마파크') ||
                    nearestPlace.category_name.includes('리조트')) {
                  placeName = nearestPlace.place_name;
                }
              }
            }

            // 2. 관광명소가 없으면 일반 장소 검색
            if (!placeName) {
              places.keywordSearch('', function(generalData, generalStatus) {
                if (generalStatus === kakao.maps.services.Status.OK && generalData.length > 0) {
                  var nearestGeneral = findNearestPlace(generalData, latitude, longitude);
                  if (calculateDistance(latitude, longitude, nearestGeneral.y, nearestGeneral.x) < 500) {
                    placeName = nearestGeneral.place_name;
                  }
                }
                
                // 3. 최종적으로 주소 표시
                if (!placeName) {
                  geocoder.coord2Address(longitude, latitude, function(result) {
                    var addr = result[0]?.road_address?.address_name || 
                              result[0]?.address?.address_name || 
                              "지정한 위치";
                    showInfoWindow(addr);
                  });
                } else {
                  showInfoWindow(placeName);
                }
              }, {
                location: new kakao.maps.LatLng(latitude, longitude),
                radius: 2000,  // 반경 2km로 확대
                sort: kakao.maps.services.SortBy.DISTANCE
              });
            } else {
              showInfoWindow(placeName);
            }
          }, {
            location: new kakao.maps.LatLng(latitude, longitude),
            radius: 2000,  // 초기 검색 반경 2km
            sort: kakao.maps.services.SortBy.DISTANCE
          });

          // 공통 함수
          function showInfoWindow(text) {
            new kakao.maps.InfoWindow({
              content: `<div style="padding:5px;font-size:13px;font-weight:bold;">${text}</div>`
            }).open(map, marker);
          }

          function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // 미터 단위
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δφ = (lat2-lat1) * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          }

          function findNearestPlace(places, targetLat, targetLng) {
            return places.reduce((nearest, current) => {
              const currentDist = calculateDistance(targetLat, targetLng, current.y, current.x);
              const nearestDist = calculateDistance(targetLat, targetLng, nearest.y, nearest.x);
              return currentDist < nearestDist ? current : nearest;
            });
          }
        } else {
          document.getElementById('post-map').style.display = 'none';
        }  
      });
    }

    // 페이지 로드 시 두 기능 모두 초기화
    $(document).ready(function() {
      // 댓글 로드
      loadComments();
      
      // 카카오맵 초기화
      initKakaoMap();
    });
    
    
  </script>
</body>
</html>
